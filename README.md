# آزمایش دوم درس آزمایشگاه مهندسی نرم افزار


## توسعه دهندگان:
- [علی صادقی](a.sadeghiali@yahoo.com)
- [بزرگمهر ضیا](bozorgmehr1381@gmail.com)
- [زهرا رحمانی](Zahra.rahmaniez@gmail.com)

- # آشنایی با اصول شئ‌گرایی (موسوم به اصول SOLID)

## اهداف

در این آزمایش هدف بر آن است که دانشجویان با به کارگیری اصول SOLID در یک پروژه‌ی عملی ساده آشنا شوند.

## نیازمندی‌ها

آشنایی اولیه با مفاهیم برنامه نویسی و طراحی شی‌گرا که دانشجویان قبلاً در درس برنامه‌سازی پیشرفته با آن آشنا شده‌اند.

## ابزارهای مورد استفاده

- یک Java IDE مانند IntelliJ IDEA و یا Eclipse به همراه jdk حداقل نسخه ۸

## منابع آموزشی

برای آشنایی با این اصول و آشنایی با منابع مناسب
به [اینجا](https://github.com/ssc-public/Software-Engineering-Lab/blob/main/educational-resources/SOLID/README.md)
مراجعه کنید.

## مقدمه

در این آزمایش شما خواهید آموخت که چگونه می‌توانید با به کارگیری اصول SOLID، نرم‌افزارهایی را بسازید که از نظر قابلیت نگهداری و بهبود، در وضعیت مطلوبی باشند و مدیریت تغییرات در آن‌ها به آسانی میسر باشد (شک نکنید که به کارگیری این اصول اساسی و بسیاری دیگر از اصول مهندسی نرم افزار، باعث تفاوت شما با سایر همکارانتان خواهد شد)

## بخش اول: توضیحاتی پیرامون برنامه‌ی داده شده

می‌توانید برنامه را
از [اینجا](https://github.com/ssc-public/Software-Engineering-Lab/tree/main/base-projects/SOLID-Principles) بارگیری
کنید.

### مفروضات مسئله

صورت آزمایش در درس افزار بارگزاری شده است و می‌توانید برای تحویل گزارش (با در نظر گرفتن ملاحظات گفته شده) از قالب های
زیر استفاده کنید.

## بخش دوم: دستور آزمایش

### گام ۱: افزودن یک روش پرداخت دیگر

	تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع پیام اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

<table dir='rtl'>
    <tbody>
        <tr>
            <td><p><strong>ردیف</strong></p></td>
            <td><p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p></td>
            <td><p><strong>عنوان تغییر</strong></p></td>
            <td><p><strong>شرحی کوتاه از تغییر</strong></p></td>
        </tr>
        <tr>
            <td><p><strong>۱</strong></p></td>
            <td><p>OrderService</p></td>
            <td><p>افزودن تابع پرداخت سفارش تلفنی</p></td>
            <td>
                <p>افزودن تابع</p>
                <p>void phoneOrderRegister(String customerName)</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۲</strong></p></td>
            <td><p>OrderService</p></td>
            <td><p>افزودن تابع ثبت سفارش تلفنی</p></td>
            <td>
                <p>افزودن تابع</p>
                <p>void phoneOrderPayment(int foodPrice)</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۳</strong></p></td>
            <td><p>OnSiteOrderService</p></td>
            <td><p>override کردن تابع phoneOrderRegister</p></td>
            <td>
                <p>پیاده سازی تابع  phoneOrderRegister با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۴</strong></p></td>
            <td><p>OnsiteOrderService</p></td>
            <td><p>override کردن تابع phoneOrderPayment</p></td>
            <td>
                <p>پیاده سازی تابع  phoneOrderPayment با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۵</strong></p></td>
            <td><p>OnlineOrderService</p></td>
            <td><p>override کردن تابع phoneOrderRegister</p></td>
            <td>
                <p>پیاده سازی تابع  phoneOrderRegister با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۶</strong></p></td>
            <td><p>OnlineOrderService</p></td>
            <td><p>override کردن تابع phoneOrderPayment</p></td>
            <td>
                <p>پیاده سازی تابع  phoneOrderPayment با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۷</strong></p></td>
            <td><p>PhoneOrderService</p></td>
            <td><p>افزودن کلاس PhoneOrderService به PaymentServices</p></td>
            <td>
                <p>افزودن کلاس با عنوان PhoneOrderService برای سفارش‌های تلفنی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۸</strong></p></td>
            <td><p>PhoneOrderService</p></td>
            <td><p>override کردن تابع onlineOrderRegister</p></td>
            <td>
                <p>پیاده سازی تابع  onlineOrderRegister با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۹</strong></p></td>
            <td><p>PhoneOrderService</p></td>
            <td><p>override کردن تابع onSiteOrderRegister</p></td>
            <td>
                <p>پیاده سازی تابع  onSiteOrderRegister با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۱۰</strong></p></td>
            <td><p>PhoneOrderService</p></td>
            <td><p>override کردن تابع onlineOrderPayment</p></td>
            <td>
                <p>پیاده سازی تابع  onlineOrderPayment با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۱۱</strong></p></td>
            <td><p>PhoneOrderService</p></td>
            <td><p>override کردن تابع onSiteOrderPayment</p></td>
            <td>
                <p>پیاده سازی تابع  onSiteOrderPayment با بدنه خالی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۱۲</strong></p></td>
            <td><p>PhoneOrderService</p></td>
            <td><p>override کردن تابع phoneOrderRegister</p></td>
            <td>
                <p>پیاده سازی تابع  phoneOrderRegister برای ثبت سفارش‌های تلفنی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۱۳</strong></p></td>
            <td><p>PhoneOrderService</p></td>
            <td><p>override کردن تابع phoneOrderPayment</p></td>
            <td>
                <p>پیاده سازی تابع  phoneOrderPayment برای پرداخت سفارش‌های تلفنی</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۱۴</strong></p></td>
            <td><p>Main</p></td>
            <td><p>افزودن روش سفارش تلفنی به راهنمای کاربر</p></td>
            <td>
                <p>افزودن سفارش تلفنی به مقدار چاپ شده در خروجی برای راهنمایی کاربر در جهت انتخاب روش سفارش</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۱۵</strong></p></td>
            <td><p>Main</p></td>
            <td><p>افزودن سفارش تلفنی به روش‌های سفارش</p></td>
            <td>
                <p>پیاده سازی سفارش تلفنی به عنوان گزینه جدید برای انتخاب روش سفارش</p>
            </td>
        </tr>
        <tr>
            <td><p><strong>۱۶</strong></p></td>
            <td><p>Main</p></td>
            <td><p>افزودن پرداخت تلفنی به روش‌های پرداخت</p></td>
            <td>
                <p>پیاده سازی پرداخت تلفنی برای انجام پرداخت در مواقع انتخاب سفارش تلفنی</p>
            </td>
        </tr>
    </tbody>
</table>

مجموع تعداد تغییرات: ۱۶

### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID

در خصوص این برنامه‌ای که نوشته شده بود و شما یک قابلیت به آن اضافه کردید، بر اساس اصول SOLID موارد نقض و یا محقق شدن هر
کدام از آن اصول را بیان کنید. در بیان موارد تحقق و نقض، علت تحقق و یا نقض را نیز به صورت کامل توضیح دهید:

<table dir='rtl'>
    <tbody>
        <tr>
            <td rowspan="2">
                <p>اصل 1</p>
                <p>Single Responsibility</p>
            </td>
            <td>
                <p><strong>موارد تحقق</strong></p>
            </td>
            <td>
                <p>
کلاس Food تنها مسئول نگهداری اطلاعات مربوط به یک نوع غذا است. همچنین کلاس Order مسئول مدیریت سفارش‌ها و محاسبه مجموع قیمت غذاها است. این دو کلاس هر کدام یک مسئولیت مشخص دارند و این مطابق با اصل SRP است.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p><strong>موارد نقض</strong></p>
            </td>
            <td>
                <p>
کلاس‌های OnSiteOrderService, OnlineOrderService, و PhoneOrderService هم وظیفه‌ی ثبت سفارش و هم پرداخت را بر عهده دارند. این کلاس‌ها باید تنها یک وظیفه مشخص داشته باشند.
                </p>
            </td>
        </tr>
        <tr>
            <td rowspan="2">
                <p>اصل 2</p>
                <p>Open-Close Principle (OCP)</p>
            </td>
            <td>
                <p><strong>موارد تحقق</strong></p>
            </td>
            <td>
                <p>
کد به گونه‌ای نوشته شده که افزودن نوع جدیدی از غذا به سادگی و بدون تغییر در کد موجود امکان‌پذیر است. برای اضافه کردن یک نوع غذای جدید کافی است یک شیء جدید از کلاس Food با نام و قیمت مشخص ایجاد کنید و آن را به سفارش اضافه کنید.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p><strong>موارد نقض</strong></p>
            </td>
            <td>
                <p>
اضافه کردن یک روش جدید برای ثبت سفارش یا پرداخت نیازمند تغییر در کلاس‌های OrderService و همچنین تغییر در پیاده‌سازی‌های مختلف آن است.
                </p>
            </td>
        </tr>
        <tr>
            <td rowspan="2">
                <p>اصل 3</p>
                <p>Liskov Substitution Principle</p>
            </td>
            <td>
                <p><strong>موارد تحقق</strong></p>
            </td>
            <td>
                <p>
کلاس‌های OnSiteOrderService, OnlineOrderService و PhoneOrderService همگی از OrderService پیروی می‌کنند و می‌توانند در جای یکدیگر استفاده شوند، اگرچه نقض‌هایی در پیاده‌سازی متدها وجود دارد. اما اصل پایه‌ای LSP این است که هر کجا از OrderService استفاده شده باشد، می‌توان از پیاده‌سازی‌های آن نیز استفاده کرد.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p><strong>موارد نقض</strong></p>
            </td>
            <td>
                <p>
پیاده‌سازی‌های مختلف OrderService (مثل OnSiteOrderService, OnlineOrderService و PhoneOrderService) شامل متدهایی هستند که هیچ کاری انجام نمی‌دهند (بدنه‌ی خالی). این باعث می‌شود که کلاس‌ها نتوانند به درستی جایگزین یکدیگر شوند.
                </p>
            </td>
        </tr>
        <tr>
            <td rowspan="2">
                <p>اصل 4</p>
                <p>Interface Segregation Principle</p>
            </td>
            <td>
                <p><strong>موارد تحقق</strong></p>
            </td>
            <td>
                <p>
در کلاس Main، انتخاب سرویس سفارش‌دهی بر اساس نوع سفارش (آنلاین، حضوری، تلفنی) به درستی انجام می‌شود و فقط متدهای مرتبط با آن نوع سفارش فراخوانی می‌شود. این تحقق نسبی از اصل ISP است، چرا که کد از یک رابط بزرگ استفاده نمی‌کند و از پیاده‌سازی‌های خاص هر نوع سفارش بهره می‌برد.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p><strong>موارد نقض</strong></p>
            </td>
            <td>
                <p>
رابط OrderService شامل متدهایی است که برخی از کلاس‌ها به آنها نیاز ندارند. برای مثال، OnSiteOrderService نیازی به متدهای onlineOrderRegister و onlineOrderPayment ندارد.
                </p>
            </td>
        </tr>
        <tr>
            <td rowspan="2">
                <p>اصل 5</p>
                <p>Dependency Inversion Principle</p>
            </td>
            <td>
                <p><strong>موارد تحقق</strong></p>
            </td>
            <td>
                <p>
کلاس Main وابسته به رابط OrderService است و نه پیاده‌سازی‌های خاص آن. این اصل در انتخاب نوع سرویس سفارش‌دهی و پرداخت مشاهده می‌شود.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p><strong>موارد نقض</strong></p>
            </td>
            <td>
                <p>-</p>
            </td>
        </tr>
    </tbody>
</table>
در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:

<table dir='rtl'>
    <tbody>
        <tr>
            <td>
                <p><strong>اصل مربوطه (از اصول </strong><strong>SOLID</strong><strong>)</strong></p>
            </td>
            <td>
                <p><strong>علت نقض</strong></p>
            </td>
            <td>
                <p><strong>راه حل پیشنهادی</strong></p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Single Responsibility</p>
            </td>
            <td>
                <p>
کلاس‌های OnSiteOrderService, OnlineOrderService, و PhoneOrderService هم وظیفه‌ی ثبت سفارش و هم پرداخت را بر عهده دارند. این کلاس‌ها باید تنها یک وظیفه مشخص داشته باشند.
                </p>
            </td>
            <td>
                <p>
بهتر است این دو وظیفه به کلاس‌های جداگانه‌ای منتقل شوند. برای مثال، کلاس‌هایی مثل RegisterService و PaymentService می‌توانند ایجاد شوند که هر کدام مسئولیت خاصی دارند.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Open-Close Principle (OCP)</p>
            </td>
            <td>
                <p>
اضافه کردن یک روش جدید برای ثبت سفارش یا پرداخت نیازمند تغییر در کلاس‌های OrderService و همچنین تغییر در پیاده‌سازی‌های مختلف آن است.
                </p>
            </td>
            <td>
                <p>
از الگوهای طراحی مانند الگوی استراتژی استفاده کنید. به این ترتیب، می‌توان رفتارهای مختلف را بدون تغییر در کدهای موجود اضافه کرد.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Liskov Substitution Principle</p>
            </td>
            <td>
                <p>
پیاده‌سازی‌های مختلف OrderService (مثل OnSiteOrderService, OnlineOrderService و PhoneOrderService) شامل متدهایی هستند که هیچ کاری انجام نمی‌دهند (بدنه‌ی خالی). این باعث می‌شود که کلاس‌ها نتوانند به درستی جایگزین یکدیگر شوند.
                </p>
            </td>
            <td>
                <p>
از کلاس‌های انتزاعی (Abstract Class) یا رابط‌های جداگانه برای انواع مختلف سفارش استفاده کنید.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Interface Segregation Principle</p>
            </td>
            <td>
                <p>
رابط OrderService شامل متدهایی است که برخی از کلاس‌ها به آنها نیاز ندارند. برای مثال، OnSiteOrderService نیازی به متدهای onlineOrderRegister و onlineOrderPayment ندارد.
                </p>
            </td>
            <td>
                <p>
رابط‌ها را به قسمت‌های کوچکتری تقسیم کنید که هر کدام تنها شامل متدهای مورد نیاز مربوط به یک نوع خاص از سفارش باشد.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Dependency Inversion Principle</p>
            </td>
            <td>
                <p>-</p>
            </td>
            <td>
                <p>-</p>
            </td>
        </tr>
    </tbody>
</table>

### گام ۳: اصلاح موارد نقض

در نهایت، بر اساس تحلیلی که انجام داده‌اید و راه حل‌هایی که در بخش قبل ارایه کردید، کد را اصلاح کرده و بر روی مخزن
گیت‌هاب و در پوشه‌ای مجزا از گام قبل commit و push کنید. انتظار می‌رود که تمامی راه حل‌های پیشنهادی خود را بر روی این
نسخه اعمال کنید و تمامی بهبودهایی که انجام می‌دهید، در جداول بخش قبل موجود باشد.

### گام ۴: بررسی مجدد تغییرات مورد نیاز

فرض کنید که گام 1 را برای کد اصلاح شده (پس از انجام گام‌های ۲ و ۳) اجرا کرده‌اید.

1. در این صورت از انجام کدام یک از تغییرات ثبت شده در جدول گام ۱ معاف خواهید شد؟

1, 2, 3, 4, 5, 6, 8, 9, 10, 11

2. تعداد تغییرات مورد نیاز، چند تغییر خواهد شد؟

6


### گام ۵: جمع بندی

در این بخش، بیان کنید که از این گام چه نتیجه‌ای گرفته‌اید؟ و به نظر شما به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴ چه
مزایایی را نسبت به حالتی دارد که این اصول رعایت نشده‌بود؟

نتیجه‌گیری نهایی:

به کارگیری اصول SOLID باعث بهبود کیفیت کد، افزایش انعطاف‌پذیری، کاهش وابستگی‌ها و افزایش قابلیت تست و نگهداری می‌شود. این اصول به توسعه‌دهندگان کمک می‌کنند تا سیستم‌های نرم‌افزاری پایدارتر، قابل نگهداری‌تر و انعطاف‌پذیرتری را ایجاد کنند که در بلندمدت به کاهش هزینه‌ها و افزایش بهره‌وری منجر می‌شود.

مزایای به کارگیری صحیح اصول SOLID نسبت به حالتی که این اصول رعایت نشده است:

بهبود قابلیت نگهداری و توسعه:

با SOLID: کدها به راحتی قابل فهم و نگهداری هستند. افزودن ویژگی‌های جدید یا تغییر در کدها بدون تأثیر منفی بر بخش‌های دیگر امکان‌پذیر است.
بدون SOLID: کدها پیچیده و در هم تنیده می‌شوند و هر تغییر کوچک ممکن است باعث بروز خطا در بخش‌های دیگر شود.
افزایش انعطاف‌پذیری:

با SOLID: سیستم به راحتی قابل توسعه است و افزودن قابلیت‌های جدید بدون تغییر در کدهای موجود امکان‌پذیر است.
بدون SOLID: افزودن قابلیت‌های جدید نیاز به تغییرات گسترده در کدهای موجود دارد که باعث افزایش ریسک خطا می‌شود.
کاهش وابستگی‌ها:

با SOLID: کلاس‌ها و ماژول‌ها به انتزاع وابسته هستند و نه به پیاده‌سازی‌های خاص. این امر باعث کاهش وابستگی‌ها و افزایش انعطاف‌پذیری می‌شود.
بدون SOLID: وابستگی‌های زیادی بین کلاس‌ها وجود دارد که باعث کاهش انعطاف‌پذیری و افزایش پیچیدگی کد می‌شود.
بهبود قابلیت تست:

با SOLID: کلاس‌ها و ماژول‌ها مستقل و کوچک هستند که تست آنها به صورت جداگانه آسان است.
بدون SOLID: تست کدها به دلیل پیچیدگی و وابستگی‌های زیاد دشوار است و احتمال بروز خطاهای ناخواسته افزایش می‌یابد.
افزایش خوانایی کد:

با SOLID: کدها به وضوح تفکیک شده و هر بخش مسئولیت مشخصی دارد که درک آن را آسان‌تر می‌کند.
بدون SOLID: کدها در هم تنیده و پیچیده هستند و درک آنها دشوار است.







## نحوه ارسال پروژه:

1. گام ۱ را انجام داده و سپس کد نوشته شده‌ی خود را (با رعایت محدودیت‌های گفته شده در گام) در یک پوشه به نام
   Step_1_Non_SOLID ذخیره کنید و در مخزن گام ۲ قرار دهید. موارد توضیحی بایستی در بخش README مخزن قرار گیرد.
2. گام ۲ (که بخش تحلیلی است) در فایل README مربوط به مخزن گام ۲ آورده شود (تمام جداول با فرمت داده شده و عناوین هرکدام
   از سوالات پرسیده شده بایستی در README آورده شود).
3. گام ۳ که شامل بهبود است، بایستی به صورت جداگانه در پوشه دیگری به نام Step_3_With_SOLID قرار داده شود و در مخزن موجود
   باشد.
4. گام ۴ نیز در قالب توضیحات در README مخزن آورده شود.
5. گام ۵ (که نتیجه گیری است) در README مخزن آورده شود.
